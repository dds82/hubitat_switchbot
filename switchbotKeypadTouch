/*

Copyright 2024 - dsegall

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-------------------------------------------

Change history:

0.9.22 dsegall Added Keypad Touch

*/

import groovy.json.JsonBuilder
import groovy.transform.Field

import java.util.Calendar

@Field static final String PERMANENT = "permanent"
@Field static final String TIMED = "timeLimit"
@Field static final String DISPOSABLE = "disposable"
@Field static final String EMERGENCY = "urgent"

@Field static final String SUCCESS = "success"
@Field static final String FAILED = "failed"
@Field static final String TIMEOUT = "timeout"

@Field static final String PASSCODE_NORMAL = "normal"
@Field static final String PASSCODE_EXPIRED = "expired"

metadata
{
    definition(name: "SwitchBot Keypad Touch", namespace: "tomw", author: "dsegall", importUrl: "")
    {
        capability "Refresh"
        capability "LockCodes"
        capability "Initialize"

        command "createKey", [[name: "Name*", type: "STRING"], [name: "Password*", type: "STRING"], [name: "Type", type: "ENUM", constraints: [PERMANENT, TIMED, DISPOSABLE, EMERGENCY]], [name: "Start Time", type: "STRING"], [name: "End Time", type: "STRING"]]
        command "deleteKey", [[name: "ID*", type: "STRING"]]
        command "deleteKeyByName", [[name: "Name*", type: "STRING"]]
    }

    preferences
    {
        section
        {
            input name: "logEnable", type: "bool", title: "Enable debug logging", defaultValue: false
            input name: "lockCodeEncryption", type: "bool", title: "Enable lock code encryption", defaultValue: false
            input name: "deleteExpiredCodes", type: "bool", title: "Automatically delete expired codes", defaultValue: true
        }
    }
}

def logDebug(msg) 
{
    if (logEnable)
    {
        log.debug(msg)
    }
}

def initialize()
{
    atomicState.pendingCommands = 0
    atomicState.needsReread = false
    sendEvent(name: "codeLength", value: 12)
    sendEvent(name: "maxCodes", value: 100)
    refresh()
}

def updated() {
    updateCodesAttr()
}

def refresh()
{
    parent?.rereadDevices(device.getDeviceNetworkId())
}

def parse(body)
{
    if (logEnable)
    logDebug("parse: ${body}")

    if (atomicState.pendingCommands > 0) atomicState.pendingCommands--

    if (body.result == "success") {
        atomicState.needsReread = true
        if (body.eventName == "createKey")
            sendEvent(name: "codeChanged", value: "added")
        else if (body.eventName == "deleteKey")
            sendEvent(name: "codeChanged", value: "deleted")

        if (atomicState.pendingCommands == 0) {
            atomicState.needsReread = false
            logDebug("Refreshing...")
            runIn(1, "refresh")
        }
    }
    else sendEvent(name: "codeChanged", value: "failed")
}

def writeDeviceCommand(command, parameter = "default", commandType = "command")
{
    def id = getParent()?.getId(device.getDeviceNetworkId())
    if(id)
    {
        getParent()?.writeDeviceCommand(id, command, parameter, commandType)
    }
}

def createKey(String name, String code, String type=PERMANENT, String startTimeS=null, String endTimeS=null) {
    if (!atomicState.lockCodesByName.containsKey(name)) {
        long startTime = 0
        long endTime = 0
        Date now = new Date()
        
        if (type == TIMED && !startTimeS) {
            startTime = now.getTime() + 5000
        }
        
        if (startTimeS) {
            Calendar cal = timeToday(startTimeS)
            Date date = cal.getTime()
            startTime = date.getTime()
            if (startTime < now.getTime())
                startTime = now.getTime() + 5000
        }
        
        if (type == TIMED && !endTimeS) {
            endTimeS = "23:59"
        }
    
        if (endTimeS) {
            Calendar cal = timeToday(endTimeS)
            Date date = cal.getTime()
            endTime = date.getTime()
        }
    
      Map params = ["name": name, "type": type, "password": code, "startTime": startTime, "endTime": endTime]
        atomicState.pendingCommands++
            try {
              writeDeviceCommand("createKey", params)
            }
        catch (Exception e) {
            logDebug("createKey failed: ${e.getMessage()}")
            atomicState.pendingCommands--
        }
    }
}

Calendar timeToday(String time) {
    Calendar today = Calendar.getInstance()
    today.set(Calendar.SECOND, 0)
    today.set(Calendar.MILLISECOND, 0)
    String[] parts = time.split(":")
    today.set(Calendar.HOUR_OF_DAY, parts[0] as int)
    today.set(Calendar.MINUTE, parts[1] as int)
    return today
}

def deleteKey(String id, boolean recordPendingCommand=true) {
    if (recordPendingCommand)
        atomicState.pendingCommands++

     logDebug("deleteKey id=${id}")
    try {
         writeDeviceCommand("deleteKey", ["id": id])
    }
    catch (Exception e) {
        logDebug("deleteKey failed: ${e.getMessage()}")
        atomicState.pendingCommands--
    }
}

def deleteKeyByName(String name, boolean recordPendingCommand=true) {
    String id = atomicState.lockCodesByName[name]
    logDebug("deleteKeyByName found key ${id}")
    if (id) {
        deleteKey(id, recordPendingCommand)
    }
}

def readDeviceDetails(details) {
    atomicState.lockCodes = []
    atomicState.lockCodesByName = [:]
    def expiredCodes = []
    
    def newCodes = []
    def newCodesByName = [:]
    
    logDebug("Details=" + details)
    for (it in details?.keyList) {
        logDebug("Code=" + it)
        newCodes << ["id": it.id, "name": it.name, "code": it.password, "iv": it.iv, "status": it.status]
        newCodesByName[it.name] = it.id
        if (it.status == PASSCODE_EXPIRED)
            expiredCodes << it.id
    }

    atomicState.lockCodes = newCodes
    atomicState.lockCodesByName = newCodesByName
    
    updateCodesAttr()

    logDebug("Found ${expiredCodes.size()} expired codes")
    if (!expiredCodes.isEmpty()) {
        cleanExpiredCodes(expiredCodes)
    }
}

def updateCodesAttr() {
    sendEvent(name: "lockCodes", value: getCodes())
}

def cleanExpiredCodes(expiredCodes) {
    boolean clean = deleteExpiredCodes == null ? true : deleteExpiredCodes
    logDebug("cleanExpiredCodes=${clean} size=${expiredCodes.size}")
    if (clean) {
        atomicState.pendingCommands += expiredCodes.size()
        for (code in expiredCodes) {
            String codeStr = code.toString()
            logDebug("Deleting expired code ${codeStr}")
            deleteKey(codeStr, false)
        }
    }
}

def deleteCode(position) {
    if (position >= 0 && position < atomicState.lockCodes.size() && atomicState.lockCodes[position])
        deleteKey(atomicState.lockCodes[position].id.toString())
}

def setCodeLength() {
    // Not supported
}

def setCode(codeposition, pincode, name) {
    deleteCode(codeposition)
    createKey(name, pincode)
}

def getCodes() {
    boolean encryptionEnabled=lockCodeEncryption == null ? false : lockCodeEncryption
    def codes = [:]
    int i = 0
    for (it in atomicState.lockCodes) {
        codes[i++] = ["name": it.name, "code": parent?.decryptPasscode(it.iv, it.code)]
    }

    String str = new JsonBuilder(codes).toString()
    return encryptionEnabled ? encrypt(str) : str
}
