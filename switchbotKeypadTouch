/*

Copyright 2024 - dsegall

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-------------------------------------------

Change history:

0.9.22 dsegall Added Keypad Touch

*/

import groovy.json.JsonBuilder
import groovy.transform.Field

import java.text.SimpleDateFormat

@Field static final String PERMANENT = "permanent"
@Field static final String TIMED = "timeLimit"
@Field static final String DISPOSABLE = "disposable"
@Field static final String EMERGENCY = "urgent"

@Field static final String SUCCESS = "success"
@Field static final String FAILED = "failed"
@Field static final String TIMEOUT = "timeout"

@Field static final String PASSCODE_NORMAL = "normal"
@Field static final String PASSCODE_EXPIRED = "expired"

metadata
{
    definition(name: "SwitchBot Keypad Touch", namespace: "tomw", author: "dsegall", importUrl: "")
    {
        capability "Refresh"
        capability "LockCodes"
        capability "Initialize"

        command "createKey", [[name: "Name*", type: "STRING"], [name: "Password*", type: "STRING"], [name: "Type", type: "ENUM", constraints: [PERMANENT, TIMED, DISPOSABLE, EMERGENCY]], [name: "Start Time", type: "STRING"], [name: "End Time", type: "STRING"]]
        command "deleteKey", [[name: "ID*", type: "STRING"]]
        command "deleteKeyByName", [[name: "Name*", type: "STRING"]]
    }

    preferences
    {
        section
        {
            input name: "logEnable", type: "bool", title: "Enable debug logging", defaultValue: false
            input name: "lockCodeEncryption", type: "bool", title: "Enable lock code encryption", defaultValue: false
        }
    }
}

def logDebug(msg) 
{
    if (logEnable)
    {
        log.debug(msg)
    }
}

def initialize()
{
    atomicState.pendingCommands = 0
    atomicState.needsReread = false
    sendEvent(name: "codeLength", value: 12)
    sendEvent(name: "maxCodes", value: 100)
    refresh()
}

def updated() {
    updateCodesAttr()
}

def refresh()
{
    parent?.rereadDevices(device.getDeviceNetworkId())
}

def parse(body)
{
    if (logEnable)
    logDebug("parse: ${body}")

    if (atomicState.pendingCommands > 0) atomicState.pendingCommands--

    if (body.result == "success") {
        atomicState.needsReread = true
        if (body.eventName == "createKey")
            sendEvent(name: "codeChanged", value: "added")
        else if (body.eventName == "deleteKey")
            sendEvent(name: "codeChanged", value: "deleted")

        if (atomicState.pendingCommands == 0) {
            atomicState.needsReread = false
            logDebug("Refreshing...")
            runIn(1, "refresh")
        }
    }
    else sendEvent(name: "codeChanged", value: "failed")
}

def writeDeviceCommand(command, parameter = "default", commandType = "command")
{
    def id = getParent()?.getId(device.getDeviceNetworkId())
    if(id)
    {
        getParent()?.writeDeviceCommand(id, command, parameter, commandType)
    }
}

def createKey(String name, String code, String type=PERMANENT, String startTimeS=null, String endTimeS=null) {
    SimpleDateFormat df = new SimpleDateFormat("HH:mm")
    Date date = startTimeS ? df.parse(startTimeS) : null
    long startTime = date ? date.getTime() : 0
    
    date = endTimeS ? df.parse(endTimeS) : null
    long endTime = date ? date.getTime() : 0
    
  Map params = ["name": name, "type": type, "password": code, "startTime": startTime, "endTime": endTime]
    atomicState.pendingCommands++
  writeDeviceCommand("createKey", params)
}

def deleteKey(String id, boolean recordPendingCommand=true) {
    if (recordPendingCommand)
        atomicState.pendingCommands++

  writeDeviceCommand("deleteKey", ["id": id])
}

def deleteKeyByName(String name, boolean recordPendingCommand=true) {
    String id = atomicState.lockCodesByName[name]
    logDebug("delete KeyByName found key ${id}")
    if (id) {
        deleteKey(id, recordPendingCommand)
    }
}

def readDeviceDetails(details) {
    atomicState.lockCodes = []
    atomicState.lockCodesByName = [:]
    def expiredCodes = []
    
    def newCodes = []
    def newCodesByName = [:]
    
    logDebug("Details=" + details)
    for (it in details?.keyList) {
        logDebug("Code=" + it)
        newCodes << ["id": it.id, "name": it.name, "code": it.password, "iv": it.iv]
        newCodesByName[it.name] = it.id
        if (it.status == PASSCODE_EXPIRED)
            expiredCodes << it.id
    }

    atomicState.lockCodes = newCodes
    atomicState.lockCodesByName = newCodesByName
    
    updateCodesAttr()

    if (!expiredCodes.isEmpty()) {
        cleanExpiredCodes(expiredCodes)
    }
}

def updateCodesAttr() {
    sendEvent(name: "lockCodes", value: getCodes())
}

def cleanExpiredCodes(expiredCodes) {
    atomicState.pendingCommands += expiredCodes.size()
    for (code in expiredCodes) deleteKey(code, false)
}

def deleteCode(position) {
    if (position >= 0 && position < atomicState.lockCodes.size() && atomicState.lockCodes[position])
        deleteKey(atomicState.lockCodes[position].id)
}

def setCodeLength() {
    // Not supported
}

def setCode(codeposition, pincode, name) {
    deleteCode(codeposition)
    createKey(name, pincode)
}

def getCodes() {
    boolean encryptionEnabled=lockCodeEncryption == null ? false : lockCodeEncryption
    def codes = [:]
    int i = 0
    for (it in atomicState.lockCodes) {
        codes[i++] = ["name": it.name, "code": parent?.decryptPasscode(it.iv, it.code)]
    }

    String str = new JsonBuilder(codes).toString()
    return encryptionEnabled ? encrypt(str) : str
}
